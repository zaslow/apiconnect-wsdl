/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2020
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

var _ = require('lodash');
const u = require('../lib/utils.js');
const copts = require('../lib/createOptions.js');
const parse = require('../lib/parse.js');
const generate = require('../lib/generateSwagger.js');
const openapiv3 = require('../lib/openApiV3.js');
const validate = require('../lib/validate.js');
const extraXSD = require('../lib/extraXSD.js');
const R = require('../lib/report.js');

const q = require('q');
// var g = require('strong-globalize')();
const g = require('../lib/strong-globalize-fake.js');

/**
 * Create an openapi from wsdl
 * @param {Buffer or String file location or String url} wsdl or zip content
 * @param {String} serviceName name of the wsdl service
 * @param {String} wsdlId id to use in the generated swagger.  Often this is the filename
 * @param options
 *     type: 'wsdl' (default) or 'wsdl-to-rest'
 *     openapiVersion: '2.0' (default) or '3.0'
 *     wssecurity: true (default) or false
 *     gateway: datapower-gateway (default) or datapower-api-gateway or micro-gateway
 *     req: request or null (used for i18n negotiation and error collection)
 *     allowExtraFiles: false (default) or true
 *     level: messages to report: DETAIL, INFO (default), WARNING, ERROR
 *     analysis: perform analysis of created openapi (default false)
 *     defaults: object to merge into openapi after generation.  Same shape as openapi
 *     auth: auth object if wsdl is protected url
 *     jsonStyle: condensed (default) or badgerfish
 *     port: (optional) port name.  If not specified, first soap port is used.
 *     mapOptions: setting to use for autogenerated assembly map. The default is
 *      {
 *           includeEmptyXMLElements: false,
 *           inlineNamespaces: false,
 *           mapEnablePostProcessingJSON: true,
 *           mapResolveXMLInputDataType: true,
 *           mapResolveApicVariables: false
 *      }
 *     mapSOAPFaults: true (default) or false.  Catch block for SOAPFaults if wsdl-to-rest
 * @return {
 *              openapi: <openapi>
 *              analysis: {  analysis messages }
 *              outArchive: content of zip file if input is a zip file
 *              outWSDL: content of output wsdl or zip file
 *         }
 */
async function createOpenApi(wsdl, serviceName, wsdlId, options) {
    let req;
    try {
        let createOptions = copts.create(options);
        req = createOptions.req;

        R.start(req, 'createOpenApi');

        // Parse the wsdl
        let allWSDLs = await parse.getJsonForWSDL(wsdl, createOptions.auth, createOptions);
        // If a configuration file was found, apply it to createOptions
        if (createOptions.config) {
            _.merge(createOptions, createOptions.config);
        }

        // getWSDLServicesAll makes sure that the allWSDLs array is correct.
        // It also gathers some informational and error messages that are added to the req.context
        parse.getWSDLServicesAll(allWSDLs, createOptions);

        // Locate the wsld entry for the indicated service
        let wsdlEntry = parse.findWSDLForServiceName(allWSDLs, serviceName, null);

        // Create a 2.0 wsdl proxy or wsdl to rest open api
        let openapi = (createOptions.type === 'wsdl-to-rest') ?
            generate.generateSwaggerForSoapToRest(wsdlEntry, serviceName, wsdlId, createOptions) :
            generate.generateSwaggerForWsdlProxy(wsdlEntry, serviceName, wsdlId, createOptions);

        // Convert to 3.0 if necessary
        if (createOptions.openapiVersion !== '2.0') {
            openapi = await openapiv3.getOpenApiV3(openapi, createOptions);
        }
        checkLimits(createOptions, openapi);

        // Add additional analysis if requested
        let result = { openapi: openapi };

        // Get the updated archive
        if (allWSDLs && allWSDLs[0].archive) {
            result.outArchive = allWSDLs[0].archive;
        }
        if (allWSDLs && allWSDLs[0]) {
            result.outWSDL = allWSDLs[0].archive || allWSDLs[0].content;
        }
        if (createOptions.analysis) {
            let analysis = await validate.sniffSwagger(openapi, createOptions);
            // The analysis object has messages from the Root (and target service)
            // Get the new validation errors
            result.analysis = analysis;
            let analysisErrors = analysis.Root.error || [];
            let openApiErrors = openapi['x-ibm-configuration']['x-ibm-apiconnect-wsdl'].messages.error || [];
            let validationErrors = _.difference(analysisErrors, openApiErrors);

            // Embed the errors into the openapi
            _.merge(openapi['x-ibm-configuration']['x-ibm-apiconnect-wsdl'].messages,
                    analysis.Root);
            if (openapi['x-ibm-configuration'].targets) {
                for (let target in openapi['x-ibm-configuration'].targets) {
                    if (analysis[target]) {
                        _.merge(openapi['x-ibm-configuration'].targets[target]['x-ibm-configuration']['x-ibm-apiconnect-wsdl'].messages,
                               analysis[target]);
                    }
                }
            }

            // If validation errors, then fail
            if (validationErrors.length > 0) {
                throw new Error(JSON.stringify(analysis));
            }
        }
        R.end(req, 'createOpenApi');
        return result;
    } catch (err) {
        R.end(req, 'createOpenApi', err);
        throw new u.convertToValidationErr(err);
    }
}

/**
* addTargetOpenApi
* @param openApi - existing openApi
* @param wsdl - Buffer containing the wsdl/zip or location of the wsdl/zip
* @param wsdlServiceName - Service
* @param createOptions
*   wssecurity
*   port: (optional) port name.  If not specified, first soap port is used.
*   req: request or null (used for i18n negotiation)
* @return promise openApi
*/
async function addTargetOpenApi(openapi, wsdl, wsdlServiceName, options) {
    let _defaults = {
        openapiVersion: (openapi.openapi) ? '3.0' : '2.0',
        gateway: openapi['x-ibm-configuration'].gateway
    };
    let createOptions = copts.create(options, _defaults);
    try {
        let result = await createOpenApi(wsdl, wsdlServiceName, wsdlServiceName, createOptions);
        // Update the references to point at the target definitions/schemas
        let tgtOpenApi = updateRefs(result.openapi, wsdlServiceName);

        openapi['x-ibm-configuration'].targets = openapi['x-ibm-configuration'].targets || {};
        openapi['x-ibm-configuration'].targets[wsdlServiceName] = tgtOpenApi;
        checkLimits(createOptions, openapi);
        return openapi;
    } catch (err) {
        throw new u.convertToValidationErr(err);
    }
}

/**
* addXSDToTargetOpenApi
* @param openApi - existing openApi
* @param xsd - Buffer containing the xsd or location of the xsd
* @param wsdlServiceName - Service
* @param createOptions
*   req: request or null (used for i18n negotiation)
* @return promise openApi
*/
async function addXSDToTargetOpenApi(openapi, xsd, wsdlServiceName, options) {
    let createOptions = copts.create(options);
    try {
        let definitions = await extraXSD.getDefinitionsForXSD(xsd, null, null, createOptions);
        definitions = updateRefs(definitions, wsdlServiceName);
        // Find the definition section of the target schema
        let tgt = openapi['x-ibm-configuration'].targets[wsdlServiceName];
        if (openapi.openapi) {
            tgt = tgt.components.schemas;
        } else {
            tgt = tgt.definitions;
        }
        // Add the new definitions
        for (let definition in definitions) {
            tgt[definition] = u.deepClone(definitions[definition]);
        }
        checkLimits(createOptions, openapi);
        return openapi;
    } catch (err) {
        throw u.convertToValidationErr(err);
    }
}

function updateRefs(json, serviceName) {
    let jsonString = JSON.stringify(json);
    let src = '#/';
    let tgt = '#/x-ibm-configuration/targets/' + serviceName + '/';
    jsonString = jsonString.replace(new RegExp(src, 'g'), tgt);
    return JSON.parse(jsonString);
}

function checkLimits(createOptions, openapi) {
    let keyCount = u.countKeys(openapi);
    if (keyCount > createOptions.limits.maxFinalKeys) {
        throw g.http(u.r(createOptions.req)).Error('The openapi is too large. ' +
        'The number of keys in the api %s exceeds the limit of %s.', keyCount, createOptions.limits.maxIntermediateKeys);
    }
}

/**
* Validates wsdl and rejects with error containing messages.
* @param locationOrContent location of WSDL or Buffer
* If a String, algorithm assumes a location on file system or url.
* If that fails, the algorithm attempts to create a base64 or binary buffer from the String
* @param options auth, req and other options.
* @returns promise of serviceData
*/
async function validateWSDL(locationOrContent, options) {
    options = copts.create(options);
    let req = options.req;
    var valErr = g.http(u.r(req)).Error('Validation Error');
    const opts = u.deepClone(options);
    opts.validate = true;
    opts.req = req;
    try {
        // Parse the wsdl
        let allWsdls = await parse.getJsonForWSDL(locationOrContent, options.auth, opts);
        // Extra validation of the wsdl definition
        let errs = [];
        for (let i = 0; i < allWsdls.length; i++) {
            errs = errs.concat(parse.sanityCheckDefinition(allWsdls[i].json.definitions, req));
        }
        for (let i = 0; i < errs.length; i++) {
            u.addValidationErr(valErr, errs[i], req);
        }
        // Get the list of services, ports, and bindings
        let serviceData = parse.getWSDLServicesAll(allWsdls, opts);

        // Validate the serviceData
        if (!serviceData ||
            !serviceData.bindings || serviceData.bindings.length == 0 ||
            !serviceData.portTypes || serviceData.bindings.portTypes == 0) {
            u.addValidationErr(valErr, g.http(u.r(req)).f('A wsdl \'definition\' was not found.'), req);
        } else if (!serviceData || !serviceData.services || serviceData.services.length == 0) {
            u.addValidationErr(valErr, g.http(u.r(req)).f('No wsdl \'services\' were found.'), req);
        } else {
            for (let service of serviceData.services) {
                if (!service.portName) {
                    u.addValidationErr(valErr,
                       g.http(u.r(req)).f('The wsdl \'service\' %s does not contain a \'port\'.', service.service),
                       req);
                }
            }
        }
        if (valErr.messages && valErr.messages.length > 0) {
            throw valErr;
        }
        // Get the updated archive
        if (allWsdls && allWsdls[0].archive) {
            serviceData.outArchive = allWsdls[0].archive;
        }
        return serviceData;
    } catch (e) {
        if (e !== valErr) {
            u.addValidationErr(valErr, e, req);
        }
        throw valErr;
    }
}

/**
* Validates xsd and rejects with error containing messages.
* @param locationOrContent location of XSD or Buffer
* If a String, algorithm assumes a location on file system or url.
* If that fails, the algorithm attempts to create a base64 or binary buffer from the String
* @param options auth, req, and other options.
* @returns promise
*/
async function validateXSD(locationOrContent, options) {
    options = copts.create(options, { strictValidation: true });

    let req = options.req;
    var valErr = g.http(u.r(req)).Error('Validation Error');
    let opts = u.deepClone(options);
    opts.validate = true;
    try {
        // Parse the wsdl
        let allWsdls = await parse.getJsonForWSDL(locationOrContent, options.auth, opts);
        parse.getWSDLServicesAll(allWsdls, opts);
    } catch (e) {
        u.addValidationErr(valErr, e, req);
        throw valErr;
    }
    return;
}

/**
* @param locationOrContent location of WSDL or Buffer
* If a String, algorithm assumes a location on file system or url.
* If that fails, the algorithm attempts to create a base64 or binary buffer from the String
* @param options auth and other options.
* @returns promise of serviceData
*/
async function introspectWSDL(locationOrContent, options) {
    // validateWSDL produces the serviceData along with an updated archive.
    // The updated archive is unnecessary when introspectWSDL is invoked.
    let serviceData = await validateWSDL(locationOrContent, options);
    delete serviceData.outArchive;
    return serviceData;
}

exports.addTargetOpenApi = addTargetOpenApi;
exports.addXSDToTargetOpenApi = addXSDToTargetOpenApi;
exports.createOpenApi = createOpenApi;
exports.introspectWSDL = introspectWSDL;
exports.validateWSDL = validateWSDL;
exports.validateXSD = validateXSD;
